<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
    <button id="orange">Orange</button>
    <button id="green">Green</button>
</body>
<script>
    // lexcial scoping and closure example
    function init() {
        var name = "Mozilla";
        function displayName() {
            console.log(name); 
        }
        displayName();
    }
    init();

    /*
    init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer scopes, displayName() can access the variable name declared in the parent function, init().
    When init() is invoked, it creates the local variable name and the inner function displayName(), and then calls displayName(). The displayName() function, when invoked, accesses the name variable of the parent function and logs its value to the console.
    */

    function makeFunc() {
        const name = "Mozilla";
        function displayName() {
            console.log(name);
        }
        return displayName;
    }
    const myFunc = makeFunc();
    myFunc();

    /*
    At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works, this is obviously not the case in JavaScript.

    The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and "Mozilla" is passed to console.log.
    */
</script>
<script>
    document.getElementById("orange").onclick = function() {
        document.body.style.backgroundColor = "orange";
    };
    document.getElementById("green").onclick = function() {
        document.body.style.backgroundColor = "green";
    };

    // this is good but what is there are 100 of colors in a array and we want to create buttons for each color, so we can use closure to achieve this
    // for example, lets just implement 2 colors only

    function clickHandler(color) {
        return function() {
            document.body.style.backgroundColor = `${color}`;
        }
    }
    document.getElementById("orange").onclick = clickHandler("orange");
    document.getElementById("green").onclick = clickHandler("green");

    /*
    if we just pass the clickHandler like
        function clickHandler(color) {
            document.body.style.backgroundColor = `${color}`;
        }
        document.getElementById("orange").onclick = clickHandler("orange");
    then the color will be undefined because the clickHandler function will be executed immediately and the color variable will be lost. 
    So by returning a function from the clickHandler function, we are creating a closure that retains the value of the color variable.
    */
</script>
</html>